use chip;
use core::cell::Cell;
use core::mem;
use kernel::common::VolatileCell;
use kernel::common::take_cell::TakeCell;
use kernel::hil::i2c;
use nvic;
use peripheral_interrupts::NvicIdx;

/* 
Master write 
After the STARTTX task has been triggered, the TWI master will generate a start condition on the TWI bus, 
followed by clocking out the address and the READ/WRITE bit set to 0 (WRITE=0, READ=1). 
The address must match the address of the slave device that the master wants to write to. 
The READ/WRITE bit is followed by an ACK/NACK bit (ACK=0 or NACK=1) generated by the slave.

After receiving the ACK/NACK bit, the TWI master will clock out the data bytes that are written to the TXD
register

*/

// Let people choose i2c 

const TWI_BASE: u32 = 0x40004000; 

#[repr(C, packed)]
#[allow(dead_code)]
pub struct Registers {
    // 0x00
    pub task_startrx: VolatileCell<u32>,
    // 0x04 
    _reserved1: [u32; 1],
    // 0x08 
    pub task_starttx: VolatileCell<u32>,
    // 0x0c
    _reserved2: [u32; 2],
    // 0x14 
    pub task_stop: VolatileCell<u32>,
    // 0x18
    _reserved3: [u32; 1],
    // 0x1c
    pub task_suspend: VolatileCell<u32>,
    // 0x20 
    pub task_resume: VolatileCell<u32>,
    // 0x24 
    _reserved4: [u32; 56],
    // 0x104 
    pub event_stopped: VolatileCell<u32>,
    // 0x108 
    pub event_rxrdy: VolatileCell<u32>,
    // 0x10c 
    _reserved5: [u32; 4],
    // 0x11c 
    pub event_txdsent: VolatileCell<u32>,
    // 0x120 
    _reserved6: [u32; 1],
    // 0x124 
    pub event_error: VolatileCell<u32>,
    // 0x128 
    _reserved7: [u32; 4],
    // 0x138 
    pub event_bb: VolatileCell<u32>,
    // 0x13c 
    _reserved8: [u32; 49],
    // 0x200 
    pub reg_short: VolatileCell<u32>,
    // 0x204 
    _reserved9: [u32; 64],
    // 0x304 
    pub reg_intenset: VolatileCell<u32>,
    // 0x308 
    pub reg_intenclr: VolatileCell<u32>,
    // 0x30c 
    _reserved10: [u32; 110],
    // 0x4c4 
    pub reg_errorsrc: VolatileCell<u32>,
    // 0x4c8 
    _reserved11: [u32; 14],
    // 0x500 
    pub reg_enable: VolatileCell<u32>,
    // 0x504 
    _reserved12: [u32; 1],
    // 0x508 
    pub reg_psel_scl: VolatileCell<u32>,
    // 0x50c 
    pub reg_psel_sda: VolatileCell<u32>,
    // 0x510 
    _reserved13: [u32; 2],
    // 0x518 
    pub reg_rxd: VolatileCell<u32>,
    // 0x51c 
    pub reg_txd: VolatileCell<u32>,
    // 0x520 
    _reserved14: [u32; 1],
    // 0x524
    pub reg_frequency: VolatileCell<u32>,
    // 0x528 
    _reserved15: [u32; 24],
    // 0x588 
    pub reg_address: VolatileCell<u32>,

}

// Three main I2C speeds
#[derive(Clone,Copy)]
pub enum Speed {
    Standard100k,
    Fast400k,
}

// This represents an abstraction of the peripheral hardware.
pub struct I2CHw {
    regs: *mut Registers,
    buffer: TakeCell<&'static mut [u8]>,
    len: Cell<usize>,
    index: Cell<usize>,
    master_client: TakeCell<&'static i2c::I2CHwMasterClient>,
    slave_client: TakeCell<&'static i2c::I2CHwSlaveClient>,
}

impl I2CHw {
    const fn new() -> I2CHw {
        I2CHw {
            regs: TWI_BASE as *mut Registers,
            buffer: TakeCell::empty(),
            len: Cell::new(0),
            index: Cell::new(0),
            master_client: TakeCell::empty(),
            slave_client: TakeCell::empty(),
        }
    }

    fn configure(&self, sda: u32, scl: u32) {
        let regs: &mut Registers = unsafe { mem::transmute(self.regs) };
        // TODO use struct to limit pins accessible by i2c
        regs.reg_psel_scl.set(sda);
        regs.reg_psel_sda.set(scl); 
    }

    pub fn enable_nvic(&self) {
        // SPI0_TWI0
        // SPI1_TWI1
        // nvic::enable(NvicIdx::???);
    }

    pub fn disable_nvic(&self) {
        // nvic::disable(NvicIdx::???);
    }

    pub fn enable_rx_interrupts(&self) {
        // let regs: &mut Registers = unsafe { mem::transmute(self.regs) };
        // regs.reg_intenset.set(1 << 3 as u32);
    }

    pub fn enable_tx_interrupts(&self) {
        let regs: &mut Registers = unsafe { mem::transmute(self.regs) };
        regs.reg_intenset.set(1 << 7 as u32);
    }

    pub fn disable_rx_interrupts(&self) {
        // let regs: &mut Registers = unsafe { mem::transmute(self.regs) };
        // regs.reg_intenclr.set(1 << 3 as u32);
    }

    pub fn disable_tx_interrupts(&self) {
        // let regs: &mut Registers = unsafe { mem::transmute(self.regs) };
        // regs.reg_intenclr.set(1 << 7 as u32);
    }

    pub fn set_master_client(&self, client: &'static i2c::I2CHwMasterClient) {
        self.master_client.replace(client);
    }

    pub fn set_slave_client(&self, client: &'static i2c::I2CHwSlaveClient) {
        self.slave_client.replace(client);
    }

    pub fn write(&self, address: u32, data: &'static mut [u8], len: usize) {
        let regs: &mut Registers = unsafe { mem::transmute(self.regs) };
        regs.reg_address.set(address); 
        self.enable_tx_interrupts();
        regs.task_starttx.set(1);
        self.buffer.replace(data); 
        self.index.set(0 as usize); 
        self.len.set(len); 

        self.buffer.map(|buffer| {
            regs.reg_txd.set(buffer[self.index.get()] as u32);
            let next_index = self.index.get() + 1;
            self.index.set(next_index);
        }); 
    }

    pub fn handle_interrupt(&mut self) { 
        let regs: &Registers = unsafe { mem::transmute(self.regs) };
        let tx_interrupt = regs.event_txdsent.get() != 0;

        if tx_interrupt {
            if self.len.get() == self.index.get() {
                regs.task_stop.set(1 as u32);
                self.index.set(0 as usize); 

                // done writing? 

                return;
            }

            self.buffer.map(|buffer| {
                regs.reg_txd.set(buffer[self.index.get()] as u32);
                let next_index = self.index.get() + 1;
                self.index.set(next_index);
            });
        }
    }
}

impl i2c::I2CMaster for I2CHw {
	/// This enables the entire I2C peripheral
    fn enable(&self) {
        // set registers to sda/scl? 
        // config as read or write? 
    }

    /// This disables the entire I2C peripheral
    fn disable(&self) {
    }

    fn write(&self, addr: u8, data: &'static mut [u8], len: u8) {
        I2CHw::write(self, addr as u32, data, len as usize);
    }

    fn read(&self, addr: u8, data: &'static mut [u8], len: u8) {
    }

    fn write_read(&self, addr: u8, data: &'static mut [u8], write_len: u8, read_len: u8) {
    }
}

impl i2c::I2CSlave for I2CHw {
    fn enable(&self) {
    }

    /// This disables the entire I2C peripheral
    fn disable(&self) {
    }

    fn set_address(&self, addr: u8) {
    }

    fn write_receive(&self, data: &'static mut [u8], max_len: u8) {
    }

    fn read_send(&self, data: &'static mut [u8], max_len: u8) {
    }

    fn listen(&self) {
    }
}

impl i2c::I2CMasterSlave for I2CHw {

}

#[no_mangle]
#[allow(non_snake_case)]
pub unsafe extern "C" fn SPI0_TWI0_Handler() {
    use kernel::common::Queue;
    nvic::disable(NvicIdx::SPI0_TWI0);
    chip::INTERRUPT_QUEUE.as_mut().unwrap().enqueue(NvicIdx::SPI0_TWI0);
}

#[no_mangle]
#[allow(non_snake_case)]
pub unsafe extern "C" fn SPI0_TWI1_Handler() {
    use kernel::common::Queue;
    nvic::disable(NvicIdx::SPI1_TWI1);
    chip::INTERRUPT_QUEUE.as_mut().unwrap().enqueue(NvicIdx::SPI1_TWI1);
}